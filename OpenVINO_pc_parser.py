#!python
import os
import sys
import time
import re
import csv
from glob import glob


"""
USAGE: python ov2.py {path-to-openvino-folder}

The folder should contain openvino output files.
Each file's name should indicate the model, device and operation type:
    model: taking the file basename for now
    device: one of the known Devices should follow an underscore
    optype: text indicating fp16, int8 (or i8), or fp32; or fp32 will be assumed by default.

"""

Devices = ['CPU', 'GPU']

def clean_model(model):
    """
        Removes the part after the underscore, repeating while model ends with underscore plus an optype or device. 
    """
    noise = Devices + ['fp16','fp32','int8','i8']
    again=False
    for oto in noise:
        if model.lower().endswith('_' + oto.lower()):
            model = model[0:-(len(oto)+1)]
            again = True
    if not again:
        return model
    return clean_model(model) # tail-end recursion?

def parse_test_filename(filename):
    """
        Endeavours to extract model, device and optype from the filename string
    """
    filename = filename.lower()
    device = None
    model = None
    for el in Devices:
        if "_" + el.lower() in filename:
            device = el

    optype = 'FP32'
    if 'fp16' in filename:
        optype = 'FP16'
    elif 'int8' in filename or 'i8' in filename:
        optype = 'Int8'
    model = filename.replace('.txt','')

    model = clean_model(model)

    return [model, device, optype]
    
def get_classification_stats(fspec):
    """
        For parsing results generated by classification_sample.exe
        Returns a list of fps and runtime
    """
    with open(fspec, 'r') as fp:
        lines = fp.readlines()
        fps = None
        runtime = None
        readtime = None
        loadtime = None
        for line in lines:
            m = re.search(r'^Throughput: (.*) FPS', line)
            if m:
                # raise exception if fps is not None
                fps = m[1]
                continue
            else:
                m = re.search(r'Average running time of one iteration: (.*) ms', line)
                if m:
                    runtime = m[1]
                    continue
            m = re.search(r'Read network took (.*) ms', line)
            if m:
                readtime = m[1]
                continue
            m = re.search(r'Load network took (.*) ms', line)
            if m:
                loadtime = m[1]
                continue
            m = re.search(r'Network input (.*)', line)
            if m:
                loadtime = m[1]
                continue

        return [fps, runtime, readtime, loadtime]


def get_benchmark_app_stats(fspec):
    """
        For parsing results generated by benchmark_app.exe
        Returns a dictionary of the four stats.
    """
    print("reading {}".format(fspec), file=sys.stderr)
    with open(fspec, 'r') as fp:
        lines = fp.readlines()
        labels = ('Count','Duration','Latency','Throughput', 'readtime', 'loadtime','network')
        stats = {}
        for label in labels:
            stats[label] = None

        for line in lines:
            m = re.split(r'\s*:\s*', line)
            if m and m[0] in labels:
                stats[m[0]] = m[1].split(' ')[0]
            m = re.search(r'Read network took (.*) ms', line)
            if m:
                stats['readtime'] = m[1]
            m = re.search(r'Load network took (.*) ms', line)
            if m:
                stats['loadtime'] = m[1]
            m = re.search(r'dimensions (.*)', line)
            if m:
                stats['network'] = m[1]
            
        return [ stats[label] for label in labels ]

def usage():
    """
    print Usage and exit
    """
    print("USAGE: {} {{path}} [csv filename]".format(sys.argv[0]))
    sys.exit(1)

def main():
    """
        Parses the benchmark app outputs in a path, and writes to stdout or optionally to a csv file
        
    """
     
    files=[]

    if len(sys.argv) == 1: 
        usage()
    else:
        path = os.path.abspath(sys.argv[1])
        if os.path.isfile(path):
            files = [path]
        else:
            files = glob("{}/*.txt".format(path))

    ofname = sys.argv[2] if len(sys.argv) > 2 else ''
    if os.path.exists(ofname):
        print("File exists!: {}".format(ofname))
        sys.exit(1)

    headers=["model", "device", "optype", "count", "duration", "latency", "FPS", "Path: {path}".format(path=path)]
    rows=[]
    for fspec in files:
        fname=os.path.basename(fspec)
        model, device, optype= parse_test_filename(fname)
        stats = get_benchmark_app_stats(fspec)
        rows.append([model, device, optype] + stats)

    csvfile = sys.stdout
    if ofname:
        csvfile = open(ofname, 'w', newline='')
    csvwriter = csv.writer(csvfile, delimiter=',', quotechar='"', quoting=csv.QUOTE_ALL)
    csvwriter.writerow(headers)

    for row in rows:
        csvwriter.writerow(row)

    if ofname:
        csvfile.close()
        print("Wrote csv file '{}'".format(ofname), file=sys.stderr)


if __name__ == '__main__':
    main()
